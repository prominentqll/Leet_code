********************************************************************************************************************************************************
题目描述：
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

解题思路：
- 建立一个256位大小的整型数组来代替哈希表，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符
- 然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置
- 然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１
  其中ｉ是最长无重复子串最右边的位置，left是最左边的位置
- 还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left位置更新了
  如果又遇到了新的字符，就要重新计算最长无重复子串。
- 最后每次都要在哈希表中将当前字符对应的值赋值为i+1
*********************************************************************************************************************************************************
代码实现：
 int lengthOfLongestSubstring(string s) {
         set<char> t;//用来保存无重复字符的集合
         int res = 0;// 保存最长无重复子串
         int left = 0;//无重复子串的起始位置
         int right = 0;//用来遍历所有的字符
         while (right < s.size()) {
             if (t.find(s[right]) == t.end()) 
             {
                /*
                * 如果s[right]不在集合中，就表示它还没有出现过
                * 没有出现过的字符插进set集合中
                * 并根据set集合的大小来不断更新res
                */
                 t.insert(s[right++]);
                 res = max(res, (int)t.size());
             }  
             else 
             {
             /*
             * 如果s[right]在集合中存在，就从集合的最左边开始删除，直到
             * 把该重复的字符在集合中删除为止
             */
                 t.erase(s[left++]);
             }
         }
         return res;
     }