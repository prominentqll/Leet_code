**************************************************************************************************
题目描述：
给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

解题思路：
1）每个节点的子节点可以有十个，比如节点1的子节点可以是10~19、节点2的子节点可以是20~29、。。。

但是由于n大小的限制，构成的并不是一个"满十叉树"。

2）分析题目中给的例子可以知道，数字1的子节点有4个(10,11,12,13)，而后面的数字2到9都没有子节点，

那么这道题实际上就变成了一个先序遍历十叉树的问题。

3）那么，难点就变成了 计算出同一层两个相邻的节点的子节点的个数，也就是代码中的steps
   当前节点为 curr  （从curr = 1 开始），则同一层的下一个节点为 curr+1;

   计算节点 curr到节点curr+1之间的子节点个数steps

   如果子节点个数 大于 k，说明第k小的树一定在子节点中，

   继续向下一层寻找：curr *=10;

   k -= 1;（原因：向下一层寻找，肯定要减少前面的父节点，即在上一层中的第k个数，在下一层中是第k-1个数）

   如果子节点个数 小于或者等于 k，说明第k小的树不在子节点中，

   继续向同一层下一个节点寻找：curr +=1;

   k -= steps;（原因：向下一层寻找，肯定要减少前面的所有的子节点）

   以此类推，直到k为0推出循环，此时cur即为所求。

***************************************************************************************************
代码实现：
 int findKthNumber(int n, int k) {
        int cur = 1;
        k--;
        
        while (k > 0)
        {
            long long left = cur;
            long long right = cur + 1;
            int node_num = 0;
            
            while (left <= n) // 统计树中每一层的节点个数
            {
                node_num += min(right, (long long)(n+1)) - left;
                left *= 10;
                right *= 10;
            }
            
            if (node_num <= k) // 向后查找
            {
                k -= node_num;
                cur++;
            }
            else // 进入子树查找
            {
                k--;
                cur *= 10;
            }
        }
        
        return cur;       
    }
