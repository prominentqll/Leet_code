
const int N = 110, M = 11;
int n, m;
int f[N][M];

int main()
{
	while (cin >> n >> m)
	{
	     // f[i][j]表示测量区间为i，且有j个鸡蛋的测量方案
		for (int i = 1; i <= n; i++) f[i][1] = i;
		for (int i = 1; i <= m; i++) f[1][i] = 1;

		for (int i = 2; i <= n; i++)
		{
			for (int j = 2; j <= m; j++)
			{
			   //情况1：没有用过鸡蛋j,说明在测量区间长度为i时，使用了j-1个鸡蛋
				f[i][j] = f[i][j - 1]; 
				
				//情况2：用了鸡蛋j,需要知道在第几层用了
				for (int k = 1; k <= i; k++)
				{
 /* 假设在k处进行了测量，又分为两种情况
 * 1. 在k处鸡蛋碎了，则测量区间变为1~k-1,区间长度为k-1,鸡蛋剩余j-1个
 * 2. 在k处鸡蛋没碎，测量区间为k+1~i,区间长度为i-k,鸡蛋剩余j个
 * 由于我们可以控制鸡蛋在哪个位置去测，没办法控制测量的结果
 * 对于我们无法控制的结果，需要取最坏的情况  max(f[k - 1][j - 1], f[i - k][j])            
 */
					f[i][j] = min(f[i][j], max(f[k - 1][j - 1], f[i - k][j]) + 1);
				}
			}
		}
		cout << f[n][m] << endl;
	}
	return 0;
}


