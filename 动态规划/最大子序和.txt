**********************************************************************************************************
题目要求：
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
解题思路：
这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来
动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果
时间复杂度：O(n)
*************************************************************************************************************
代码实现：
int maxSubArray(vector<int>& nums) {
        int size=nums.size();
        if(size==0)
        {
            return -1;
        }
        vector<int> res(size);
        res[0]=nums[0];
        int max=nums[0];
        res[0]=nums[0];
        
        for(int i=1;i<size;++i)
        {
            if(res[i-1]>0)//前一次结果大于0
            {
                res[i]=res[i-1]+nums[i];//当前结果为前一次的结果加上当前元素得值
            }
            else//前一次的结果小于0
            {
                res[i]=nums[i];//当前结果重置为当前元素的值
            }
            if(res[i]>max)
            {
                max=res[i];//更新max
            }
            
        }
        return max;
        
    }
