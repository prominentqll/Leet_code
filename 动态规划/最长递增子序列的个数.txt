********************************************************************************
题目描述：
给定一个未排序的整数数组，找到最长递增子序列的个数。
示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。

解题思路：
动态规划
dp[i]代表到第i个元素为止的最长递增子序列的长度

*********************************************************************************

代码实现：
int findNumberOfLIS(vector<int>& nums) {
     int size = nums.size();
        if(size==0)
        {
            return 0;
        }
    //dp[i]代表到第i个元素为止的最长递增子序列的长度
	vector<int> dp(size);
	//res[i]代表到第i个元素为止的最长递增子序列的个数
	vector<int> res(size);
	int max = 1;//最长递增子序列的长度
	int count = 0;//最长递增子序列的个数
	

	dp[0] = 1;
	res[0] = 1;
	for (int i = 1; i < size; ++i)
	{
		dp[i] = 1;
		res[i] = 1;
		for (int j = 0; j < i; ++j)
		{
			if (nums[i] > nums[j])
			{
			//如果以nums[j]结尾的最长递增子序列长度 + 1 > 以nums[i]结尾的最长递增子序列长度
				if (dp[j] + 1 > dp[i])
				{
					dp[i] = dp[j] + 1;//更新以nums[i]结尾的最长递增子序列的长度
					res[i] = res[j];//nums[i]结尾的最长递增子序列的个数就是dp[j]的个数res[j]
				}
				else if (dp[j] + 1 == dp[i])//如果以nums[j]结尾的最长递增子序列长度 + 1 == 以nums[i]结尾的最长递增子序列长度
				{
					res[i] += res[j];//以nums[i]结尾的最长递增子序列的个数增加
                    
				}
			}
		}
		if (dp[i] > max)// 当前递增子序列的长度大于max，max要进行更新
		{
			max = dp[i];
		}
	}
	for (int i = 0; i < size; ++i)
	{
		if (dp[i] == max)//代表到第i个元素为止的最长递增子序列的长度等于最长递增子序列的长度，取其个数进行相加
		{
			count += res[i];
		}
	}
	return count;
  }