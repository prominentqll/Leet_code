****************************************************************************************
题目描述：
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"

示例 2:
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

解题思路：

使用动态规划的方法：
dp[i]：表示以第i位为结尾的最长有效括号的长度

存在三种情况：
1.如果s[i]=='(',直接返回。(因为以左括号结尾，必然不会是有效括号)
2.s[i]==')'&&s[i-1]=='(',此时dp[i]=dp[i-2]+2;
3.s[i]==')'&&s[i-1]==')', 此时与该右括号匹配的左括号有可能在i-1之前
  需要计算该右括号的对称位置(i-1-dp[i-1]),如果该位置存在且s[i-1-dp[i-1]]=='('
  则s[i]=2+dp[i-2]+dp[i-2-dp[i-1]];
***************************************************************************************

代码实现：
int longestValidParentheses(string s) 
{
	int len = s.length();
	if (len == 0)
	{
		return 0;
	}
	vector<int> dp(len,0);
	int res = 0;
	for (int i = 1; i < len; ++i)
	{
		if (s[i] == ')')
		{
			if (s[i - 1] == '(')
			{
				dp[i] = 2 + (i - 2 >= 0 ? dp[i - 2] : 0));
			}
			else
			{
				if (i - 1 - dp[i - 1] >= 0 && s[i - 1 - dp[i - 1]] == '(')
				{
					dp[i] = 2 + dp[i - 1] + (i - 2 - dp[i - 1] >= 0 ? dp[i - 2 - dp[i - 1]] : 0);
				}
			}
		}
		res = max(res, dp[i]);
	}
	return res;
}




